# ecom-app
This is a Microservice based Ecom application to demostrate the different technologies and strategies applied for creating the backend of the Microservice based architecture and how those microservices communicate with each other to fulfil user requests

## Pre-Requisites
* Docker
* JDP 17

## Understanding folder structure
This project has currently 5 folders, each folder corresponds to a Microservice, so the Service include 5 Microservices as :
* **ecom-service-registry** : Eureka based Service registry Service to manage the communication between different microservice and to make it easy for 1 micoservice to discovery all other microservices in the system
* **api-gateway-service** : Gateway microservice that act as a reverse proxy to manage the user requests and route the request to the right Microservice. Additional it provides Authenticating the JWT token and filtering the requests based on the User role
* **user-service** : To handle user registration (user/admin), token generation and token validation.
* **product-service** : Service to manage product details, inventory daya and Product Category data. This Service handles all the product related transactions such as validating order request and updating the inventory for each order
* **order-service** : Service to handle order related requests such as creating new order, fetching order details etc. This service use JWT token generated by uder-servicem throughout to identify the user and control access to order data for each user

## Deployement
### Deploying in Containarized Environment
All the microservices are spring based that are built using maven, you can build, test and package each microservice independently using mvn build commands. For easy build, I have created a bash script. This script will Clean build, package and create docker images for each microservice
Make sure you are at root folder for executing these scripts.
```
bash ./buildImages.sh
```
Once the built and packaging is successful for each microservice, check if all the docker images are created successfully
```
docker image ls
```
If the list has all the required images, you can deploy each docker image seperately or use the `docker compose` to deploy all the microservices together in the same network
```
docker compose up -d
```
This will start 1 docker container for each microservice + 1 container for postgres DB. Check if all the containers are created and deployed successfully :
```
docker container ls
```
If you want to deploy more than one instance for any microservice, update the `docker-compose.yml` file with same configuration, but choose a different local port to resolve conflict. For eample, add this config if you want to deploy another instance for user service 
```
  user-service-2:
    image: user-service
    ports:
      - 9007:9003
    networks: 
      - backendNetwork
    environment:
      - SPRING_PROFILES_ACTIVE=prod
```
This will create a new user service instance which will itself register to service registry microservice and eureka will auto load balance the requests between 2 instances of user-service

## Local Testing
For local testing you can use mvn commands to build and deploy each microservice seperately. Running through the local will use default properties file. Make sure you have a postgres server running on your local and is configured the the application properties file for each microservice

## APIs
### User APIs :
* `POST /user/register` : To register a new user with `user` role
* `POST /user/admin/register` : To register a new user with `admin` role
* `POST /user/token`: to generate a token for a registered user
* `GET /user/data` : to check the data store in the JWT token (For debugging purpose)
* `GET /user/validate` : to check if a token is valid

### Product APIs :
* `POST /product/category` : to create a new product category
* `GET /product/category` : get all categories
* `POST /product/` : create a new product
* `PUT /product/{pid}` : Update product details or create if product doesn't exist
* `PUT /product/order` : THis API is meant to be used during ordering flow to check the inventory and update the invetory for each order
* `GET /product/` : Get all products
* `GET /product/{pid}` : get details of a specific product

### Order APIs (These APIs require a Auth token with `user` role) :
* `POST /order/` : To create a new order
* `GET /order/` : Get all orders
* `GET/order/{id}` :  Get order details for a specific order

## TODO Checklist :
* Add pending unit tests
* Rate limiting
* Add caching for product apis
* Add a frontend and hide the backend in a private network
